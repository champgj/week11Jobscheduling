# 1. 근사알고리즘

## 1.1) 근사알고리즘이란

### 1.1.1) 삽입정렬이란?

삽입 정렬은 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 부분(앞부분)과 비교하여, 

자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 정렬 방법입니다.

삽입 정렬은 한 번에 한 요소의 위치만 결정되기 때문에 비효율적이다.

삽입 정렬은 입력되는 초기리스트가 "거의 정렬"되어 있을 경우 효율적이다.

### 1.1.2) 버블정렬이란?

이웃하는 숫자를 비교하여 작은 수를 앞쪽으로 이동시키는 과정을 반복하여 정렬하는 알고리즘으로 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 끝부터 정렬한다.

데이터를 하나씩 비교해서 비교횟수가 많아지므로 성능면에서 좋지 않다.

속도에 대한 설명은 밑에서 자세하게 다루겠습니다.

### 1.1.3) 선택정렬이란?

먼저 데이터 중에서 최소값을 찾고 그 값을 맨 앞에 위치한 값과 교체하고 그것을 반복하는 정렬이다.

선택 정렬이 가장 좋은 성능을 내는 자료는 내림차순 자료이다. 

반대로 이미 어느정도 정렬된 상태에서는 속도가 느리다.

속도에 대한 설명은 밑에서 자세하게 다루겠습니다.

### 1.1.4) 쉘정렬이란?

정렬의 이름은 창안자 도널드 셸의 이름을 따서 붙여졌다. 

셸 정렬은 자료를 특정 길이로 쪼개서, 각 쪼개진부분에서 정렬을 수행한다.

길이를 더 줄이는 과정을 반복해서쪼개진 길이가 1이되었을 때 완전히 정렬된다.

만약 어떤 데이터가 원래 있어야될 위치에서 멀리 있다면 

여러 번의 교환이 발생하는 버블정렬의 단점을 해결할 수 있다.



# 2. JobScheduling구현코드

## 2.1) 설계과정

1. 삽입,버블,선택,쉘 정렬을 구현한다.
2. 인터페이스로 구현해서 한개의 Sorter로 묶는다.
3. 내림차순, 어느정도정렬된 배열, 랜덤 데이터 배열을 만든다.
4. 데이터들도 인터페이스로 구현해서 한개의 data로 묶는다.
5. 각각의 데이터들을 4가지의 정렬로 정렬하고 그 시간을 측정한다.



## 2.2) 정렬코드

### 2.2.1) Sorter 인터페이스

```java
public interface Sorter {
    public int[] sort(int[]A);
}

```



### 2.2.2) 삽입정렬

 ```java
public static class bubbleSort implements Sorter {

        @Ov
 ```



### 2.2.3) 버블정렬

 ```java
 public static class insertionSort implements Sorter {

     
    }
 ```



### 2.2.4) 선택정렬

 ```java
public static class selectionSort implements Sorter {
        @Override
     
            return A;
        }
    }
 ```



### 2.2.5) 쉘정렬

 ```java
public static class shellSort implements Sorter {
        //쉘정렬은 기본적으로 구간만 나눠서 계산하고 그 나눠진 구간안에서는 삽입정렬로 구현할 수 있다.
        @Override

            return A;
        }
    }
 ```

**직접 측정해보니 gap을 A.length/2 로 계속 1/2로 줄여나가는 것 보다 **

**N-1/3이 더 빨라서 h = (A.length-1) / 3 로 작성하였다.**

이것에 대해서는 밑에서 다시 다루겠습니다.

### 2.2.6) 정렬전체

```java
public class allSort {
    //ppt 참고하니 풀만했다!

    pu
            return A;
        }
    }
}
```





### 2.5) 출력결과

![image-20210506210023527](https://user-images.githubusercontent.com/75067408/117295640-0f0dbb00-aeaf-11eb-9671-87342d647457.png)



(결과 내용이 많이 길어서 밑에 표로 전체정리하였습니다.)

각각의 숫자는

1. 삽입 2. 버블 3. 선택 4. 쉘

1. 랜덤 2. 어느정도 3. 내림

을 나타낸다.



# 3. 성능비교

## 3.1) 각 정렬별 장단점





## 3.2) 각 데이터별 정렬의 시간복잡도





## 3.3) 각 데이터 별 성능비교

### 3.3.1) 정렬별 시간복잡도

각 정렬의 특성을 파악해보자면,

1. 삽입정렬에서 내림차순>랜덤>어느정도 순이고, 어느정도 정렬된 배열에서는 속도가 빨랐다.

2. 버블정렬에서는 내림차순>랜덤>어느정도 순이고, 전체적으로 속도가 느리지만 어느정도 정렬된 배열을 정렬했을때 그나마 속도가 빨랐다.
3. 선택정렬에서는 내림차순>랜덤>어느정도 순이고, 전체적으로 세가지 타입의 속도가 비슷했다.
4. 쉘정렬의 시간복잡도가 그래프상에서는 이상해보이지만 수치 상 거의 일정하게 빠른 속도를 보여주고 있다.



### 3.3.2) 데이터종류별 시간복잡도



모든 데이터 타입에서 쉘정렬이 우세했다.

1. 랜덤배열에서는 버블정렬>선택정렬>삽입정렬>쉘정렬 순이고 버블정렬의 속도가 제일 느렸다.

2. 어느정도 정렬된 배열에서는 선택정렬>버블정렬>삽입정렬,쉘정렬 순이고 삽입정렬은 이 어느정도 정렬된 배열에서 조금 좋은 성능을 낼 수 있다. 다만 버블정렬과 선택정렬은 매우 느린 결과를 볼 수 있다.
3. 내림차순 배열에서는 버블정렬>선택정렬>삽입정렬>쉘정렬 순이다.



### 3.3.3) 전체 시간복잡도



같은 정렬방식이라도 코드로 짜는 방법의 차이로 그래프가 다르게 나올 수 있을 것 같다.



### 3.3.4) 실제 데이터 정렬 시간 표이다.

전체적으로 쉘정렬의 속도가 매우 빨랐다.

예상과 같이 어느정도 



## p.s.) 쉘 정렬에서 지금까지 알려진 가장 좋은 성능을 보인 간격들

최적격차!

쉘정렬에서의 중요한 문제는 비교된 요소들 사이의 최적의 간격을 결정하는 것이다.

최고의 성능은 Marcin Ciura의  1, 4, 10, 23, 57, 132, 301, 701, 1750 의 시퀀스에 의해 제공된다.

또한 Knuth’s sequence: k = 3k + 1 도 있다.

제가 작성한 코드도 Knuth’s sequence를 이용해서 작성했습니다.





